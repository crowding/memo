% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/cache.R
\name{strategies}
\alias{digest_key}
\alias{hybrid_key}
\alias{pointer_key}
\alias{strategies}
\title{Strategies for caching items.}
\usage{
digest_key(fn, cache)

pointer_key(fn, cache)

hybrid_key(cache)
}
\arguments{
\item{fn}{A function whose results should be cached.}

\item{cache}{A cache object.}
}
\value{
A memoized function.
}
\description{
The function \code{\link{memo}} accepts an argument `key` which
specifies the keying strategy.

\code{digest_key} is the default key strategy. It computes a key by
hashing the contents of the object using the digest package. No
attempt is made to avoid MD5 hash collisions.

The \code{pointer_key} strategy bases its key on object identity,
(that is, pointer equivalence.)  This can be faster because hte
entire object need not be hrbashed. However, this is only useful when
the function is called on the same object repeatedly and that
object is not copied.

The \code{hybrid_key} strategy first tries object identity and then
falls back on computing the md5 digest. Note that this method uses
twice as many cache slots, since the MD5 digest results are stored
in the same cache.
}

